// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/BasicTypes.proto

package proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The functionality provided by hedera hashgraph
type HederaFunctionality int32

const (
	HederaFunctionality_NONE                    HederaFunctionality = 0
	HederaFunctionality_CryptoTransfer          HederaFunctionality = 1
	HederaFunctionality_CryptoUpdate            HederaFunctionality = 2
	HederaFunctionality_CryptoDelete            HederaFunctionality = 3
	HederaFunctionality_CryptoAddClaim          HederaFunctionality = 4
	HederaFunctionality_CryptoDeleteClaim       HederaFunctionality = 5
	HederaFunctionality_ContractCall            HederaFunctionality = 6
	HederaFunctionality_ContractCreate          HederaFunctionality = 7
	HederaFunctionality_ContractUpdate          HederaFunctionality = 8
	HederaFunctionality_FileCreate              HederaFunctionality = 9
	HederaFunctionality_FileAppend              HederaFunctionality = 10
	HederaFunctionality_FileUpdate              HederaFunctionality = 11
	HederaFunctionality_FileDelete              HederaFunctionality = 12
	HederaFunctionality_CryptoGetAccountBalance HederaFunctionality = 13
	HederaFunctionality_CryptoGetAccountRecords HederaFunctionality = 14
	HederaFunctionality_CryptoGetInfo           HederaFunctionality = 15
	HederaFunctionality_ContractCallLocal       HederaFunctionality = 16
	HederaFunctionality_ContractGetInfo         HederaFunctionality = 17
	HederaFunctionality_ContractGetBytecode     HederaFunctionality = 18
	HederaFunctionality_GetBySolidityID         HederaFunctionality = 19
	HederaFunctionality_GetByKey                HederaFunctionality = 20
	HederaFunctionality_CryptoGetClaim          HederaFunctionality = 21
	HederaFunctionality_CryptoGetStakers        HederaFunctionality = 22
	HederaFunctionality_FileGetContents         HederaFunctionality = 23
	HederaFunctionality_FileGetInfo             HederaFunctionality = 24
	HederaFunctionality_TransactionGetRecord    HederaFunctionality = 25
	HederaFunctionality_ContractGetRecords      HederaFunctionality = 26
	HederaFunctionality_CryptoCreate            HederaFunctionality = 27
	HederaFunctionality_SystemDelete            HederaFunctionality = 28
	HederaFunctionality_SystemUndelete          HederaFunctionality = 29
	HederaFunctionality_ContractDelete          HederaFunctionality = 30
	HederaFunctionality_Freeze                  HederaFunctionality = 31
	HederaFunctionality_CreateTransactionRecord HederaFunctionality = 32
	HederaFunctionality_CryptoAccountAutoRenew  HederaFunctionality = 33
	HederaFunctionality_ContractAutoRenew       HederaFunctionality = 34
	HederaFunctionality_getVersion              HederaFunctionality = 35
	HederaFunctionality_TransactionGetReceipt   HederaFunctionality = 36
)

var HederaFunctionality_name = map[int32]string{
	0:  "NONE",
	1:  "CryptoTransfer",
	2:  "CryptoUpdate",
	3:  "CryptoDelete",
	4:  "CryptoAddClaim",
	5:  "CryptoDeleteClaim",
	6:  "ContractCall",
	7:  "ContractCreate",
	8:  "ContractUpdate",
	9:  "FileCreate",
	10: "FileAppend",
	11: "FileUpdate",
	12: "FileDelete",
	13: "CryptoGetAccountBalance",
	14: "CryptoGetAccountRecords",
	15: "CryptoGetInfo",
	16: "ContractCallLocal",
	17: "ContractGetInfo",
	18: "ContractGetBytecode",
	19: "GetBySolidityID",
	20: "GetByKey",
	21: "CryptoGetClaim",
	22: "CryptoGetStakers",
	23: "FileGetContents",
	24: "FileGetInfo",
	25: "TransactionGetRecord",
	26: "ContractGetRecords",
	27: "CryptoCreate",
	28: "SystemDelete",
	29: "SystemUndelete",
	30: "ContractDelete",
	31: "Freeze",
	32: "CreateTransactionRecord",
	33: "CryptoAccountAutoRenew",
	34: "ContractAutoRenew",
	35: "getVersion",
	36: "TransactionGetReceipt",
}

var HederaFunctionality_value = map[string]int32{
	"NONE":                    0,
	"CryptoTransfer":          1,
	"CryptoUpdate":            2,
	"CryptoDelete":            3,
	"CryptoAddClaim":          4,
	"CryptoDeleteClaim":       5,
	"ContractCall":            6,
	"ContractCreate":          7,
	"ContractUpdate":          8,
	"FileCreate":              9,
	"FileAppend":              10,
	"FileUpdate":              11,
	"FileDelete":              12,
	"CryptoGetAccountBalance": 13,
	"CryptoGetAccountRecords": 14,
	"CryptoGetInfo":           15,
	"ContractCallLocal":       16,
	"ContractGetInfo":         17,
	"ContractGetBytecode":     18,
	"GetBySolidityID":         19,
	"GetByKey":                20,
	"CryptoGetClaim":          21,
	"CryptoGetStakers":        22,
	"FileGetContents":         23,
	"FileGetInfo":             24,
	"TransactionGetRecord":    25,
	"ContractGetRecords":      26,
	"CryptoCreate":            27,
	"SystemDelete":            28,
	"SystemUndelete":          29,
	"ContractDelete":          30,
	"Freeze":                  31,
	"CreateTransactionRecord": 32,
	"CryptoAccountAutoRenew":  33,
	"ContractAutoRenew":       34,
	"getVersion":              35,
	"TransactionGetReceipt":   36,
}

func (x HederaFunctionality) String() string {
	return proto.EnumName(HederaFunctionality_name, int32(x))
}

func (HederaFunctionality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{0}
}

// Each shard has a nonnegative shard number. Each realm within a given shard has a nonnegative realm number (that number might be reused in other shards). And each account, file, and smart contract instance within a given realm has a nonnegative number (which might be reused in other realms). Every account, file, and smart contract instance is within exactly one realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2 within realm 1  within shard 0.  Each realm maintains a single counter for assigning numbers,  so if there is a file with ID 0.1.2, then there won't be an account or smart  contract instance with ID 0.1.2.
//
//Everything is partitioned into realms so that each Solidity smart contract can  access everything in just a single realm, locking all those entities while it's  running, but other smart contracts could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized somewhat, even though the  language itself assumes everything is serial.
type ShardID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardID) Reset()         { *m = ShardID{} }
func (m *ShardID) String() string { return proto.CompactTextString(m) }
func (*ShardID) ProtoMessage()    {}
func (*ShardID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{0}
}

func (m *ShardID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ShardID.Unmarshal(m, b)
}
func (m *ShardID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ShardID.Marshal(b, m, deterministic)
}
func (m *ShardID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardID.Merge(m, src)
}
func (m *ShardID) XXX_Size() int {
	return xxx_messageInfo_ShardID.Size(m)
}
func (m *ShardID) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardID.DiscardUnknown(m)
}

var xxx_messageInfo_ShardID proto.InternalMessageInfo

func (m *ShardID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

// The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and contract instance belongs to exactly one realm.
type RealmID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RealmID) Reset()         { *m = RealmID{} }
func (m *RealmID) String() string { return proto.CompactTextString(m) }
func (*RealmID) ProtoMessage()    {}
func (*RealmID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{1}
}

func (m *RealmID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RealmID.Unmarshal(m, b)
}
func (m *RealmID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RealmID.Marshal(b, m, deterministic)
}
func (m *RealmID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RealmID.Merge(m, src)
}
func (m *RealmID) XXX_Size() int {
	return xxx_messageInfo_RealmID.Size(m)
}
func (m *RealmID) XXX_DiscardUnknown() {
	xxx_messageInfo_RealmID.DiscardUnknown(m)
}

var xxx_messageInfo_RealmID proto.InternalMessageInfo

func (m *RealmID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *RealmID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

// The ID for an a cryptocurrency account
type AccountID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	AccountNum           int64    `protobuf:"varint,3,opt,name=accountNum,proto3" json:"accountNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountID) Reset()         { *m = AccountID{} }
func (m *AccountID) String() string { return proto.CompactTextString(m) }
func (*AccountID) ProtoMessage()    {}
func (*AccountID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{2}
}

func (m *AccountID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountID.Unmarshal(m, b)
}
func (m *AccountID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountID.Marshal(b, m, deterministic)
}
func (m *AccountID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountID.Merge(m, src)
}
func (m *AccountID) XXX_Size() int {
	return xxx_messageInfo_AccountID.Size(m)
}
func (m *AccountID) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountID.DiscardUnknown(m)
}

var xxx_messageInfo_AccountID proto.InternalMessageInfo

func (m *AccountID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *AccountID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *AccountID) GetAccountNum() int64 {
	if m != nil {
		return m.AccountNum
	}
	return 0
}

// The ID for a file
type FileID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	FileNum              int64    `protobuf:"varint,3,opt,name=fileNum,proto3" json:"fileNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FileID) Reset()         { *m = FileID{} }
func (m *FileID) String() string { return proto.CompactTextString(m) }
func (*FileID) ProtoMessage()    {}
func (*FileID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{3}
}

func (m *FileID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FileID.Unmarshal(m, b)
}
func (m *FileID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FileID.Marshal(b, m, deterministic)
}
func (m *FileID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileID.Merge(m, src)
}
func (m *FileID) XXX_Size() int {
	return xxx_messageInfo_FileID.Size(m)
}
func (m *FileID) XXX_DiscardUnknown() {
	xxx_messageInfo_FileID.DiscardUnknown(m)
}

var xxx_messageInfo_FileID proto.InternalMessageInfo

func (m *FileID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *FileID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *FileID) GetFileNum() int64 {
	if m != nil {
		return m.FileNum
	}
	return 0
}

// The ID for a smart contract instance
type ContractID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	ContractNum          int64    `protobuf:"varint,3,opt,name=contractNum,proto3" json:"contractNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContractID) Reset()         { *m = ContractID{} }
func (m *ContractID) String() string { return proto.CompactTextString(m) }
func (*ContractID) ProtoMessage()    {}
func (*ContractID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{4}
}

func (m *ContractID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContractID.Unmarshal(m, b)
}
func (m *ContractID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContractID.Marshal(b, m, deterministic)
}
func (m *ContractID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractID.Merge(m, src)
}
func (m *ContractID) XXX_Size() int {
	return xxx_messageInfo_ContractID.Size(m)
}
func (m *ContractID) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractID.DiscardUnknown(m)
}

var xxx_messageInfo_ContractID proto.InternalMessageInfo

func (m *ContractID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *ContractID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *ContractID) GetContractNum() int64 {
	if m != nil {
		return m.ContractNum
	}
	return 0
}

// The ID for a transaction. This is used for retrieving receipts and records for a transaction, for appending to a file right after creating it, for instantiating a smart contract with bytecode in a file just created, and internally by the network for detecting when duplicate transactions are submitted. A user might get a transaction processed faster by submitting it to N nodes, each with a different node account, but all with the same TransactionID. Then, the transaction will take effect when the first of all those nodes submits the transaction and it reaches consensus. The other transactions will not take effect. So this could make the transaction take effect faster, if any given node might be slow. However, the full transaction fee is charged for each transaction, so the total fee is N times as much if the transaction is sent to N nodes.
type TransactionID struct {
	TransactionValidStart *Timestamp `protobuf:"bytes,1,opt,name=transactionValidStart,proto3" json:"transactionValidStart,omitempty"`
	AccountID             *AccountID `protobuf:"bytes,2,opt,name=accountID,proto3" json:"accountID,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}   `json:"-"`
	XXX_unrecognized      []byte     `json:"-"`
	XXX_sizecache         int32      `json:"-"`
}

func (m *TransactionID) Reset()         { *m = TransactionID{} }
func (m *TransactionID) String() string { return proto.CompactTextString(m) }
func (*TransactionID) ProtoMessage()    {}
func (*TransactionID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{5}
}

func (m *TransactionID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionID.Unmarshal(m, b)
}
func (m *TransactionID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionID.Marshal(b, m, deterministic)
}
func (m *TransactionID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionID.Merge(m, src)
}
func (m *TransactionID) XXX_Size() int {
	return xxx_messageInfo_TransactionID.Size(m)
}
func (m *TransactionID) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionID.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionID proto.InternalMessageInfo

func (m *TransactionID) GetTransactionValidStart() *Timestamp {
	if m != nil {
		return m.TransactionValidStart
	}
	return nil
}

func (m *TransactionID) GetAccountID() *AccountID {
	if m != nil {
		return m.AccountID
	}
	return nil
}

// Unique identifier for a topic (used by the consensus service)
type TopicID struct {
	ShardNum             int64    `protobuf:"varint,1,opt,name=shardNum,proto3" json:"shardNum,omitempty"`
	RealmNum             int64    `protobuf:"varint,2,opt,name=realmNum,proto3" json:"realmNum,omitempty"`
	TopicNum             int64    `protobuf:"varint,3,opt,name=topicNum,proto3" json:"topicNum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TopicID) Reset()         { *m = TopicID{} }
func (m *TopicID) String() string { return proto.CompactTextString(m) }
func (*TopicID) ProtoMessage()    {}
func (*TopicID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{6}
}

func (m *TopicID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TopicID.Unmarshal(m, b)
}
func (m *TopicID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TopicID.Marshal(b, m, deterministic)
}
func (m *TopicID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicID.Merge(m, src)
}
func (m *TopicID) XXX_Size() int {
	return xxx_messageInfo_TopicID.Size(m)
}
func (m *TopicID) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicID.DiscardUnknown(m)
}

var xxx_messageInfo_TopicID proto.InternalMessageInfo

func (m *TopicID) GetShardNum() int64 {
	if m != nil {
		return m.ShardNum
	}
	return 0
}

func (m *TopicID) GetRealmNum() int64 {
	if m != nil {
		return m.RealmNum
	}
	return 0
}

func (m *TopicID) GetTopicNum() int64 {
	if m != nil {
		return m.TopicNum
	}
	return 0
}

// A Key can be a public key from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. And similarly for RSA and ECDSA.
//
// A Key can be a smart contract ID, which means that smart contract is to authorize operations as if it had signed with a key that it owned. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key.
//
// A key can be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements.
//
// A Key can be a list of keys. Their use is dependent on context. For example, a Hedera file is created with a list of keys, where all of them must sign a transaction to create or modify the file, but only one of them is needed to sign a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold key, and sometimes acts as an M-of-M threshold key.
//
// A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive keys (e.g., ed25519) has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive keys (e.g., ed25519) has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
//
// Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
type Key struct {
	// Types that are valid to be assigned to Key:
	//	*Key_ContractID
	//	*Key_Ed25519
	//	*Key_RSA_3072
	//	*Key_ECDSA_384
	//	*Key_ThresholdKey
	//	*Key_KeyList
	Key                  isKey_Key `protobuf_oneof:"key"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Key) Reset()         { *m = Key{} }
func (m *Key) String() string { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()    {}
func (*Key) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{7}
}

func (m *Key) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Key.Unmarshal(m, b)
}
func (m *Key) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Key.Marshal(b, m, deterministic)
}
func (m *Key) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Key.Merge(m, src)
}
func (m *Key) XXX_Size() int {
	return xxx_messageInfo_Key.Size(m)
}
func (m *Key) XXX_DiscardUnknown() {
	xxx_messageInfo_Key.DiscardUnknown(m)
}

var xxx_messageInfo_Key proto.InternalMessageInfo

type isKey_Key interface {
	isKey_Key()
}

type Key_ContractID struct {
	ContractID *ContractID `protobuf:"bytes,1,opt,name=contractID,proto3,oneof"`
}

type Key_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,2,opt,name=ed25519,proto3,oneof"`
}

type Key_RSA_3072 struct {
	RSA_3072 []byte `protobuf:"bytes,3,opt,name=RSA_3072,json=RSA3072,proto3,oneof"`
}

type Key_ECDSA_384 struct {
	ECDSA_384 []byte `protobuf:"bytes,4,opt,name=ECDSA_384,json=ECDSA384,proto3,oneof"`
}

type Key_ThresholdKey struct {
	ThresholdKey *ThresholdKey `protobuf:"bytes,5,opt,name=thresholdKey,proto3,oneof"`
}

type Key_KeyList struct {
	KeyList *KeyList `protobuf:"bytes,6,opt,name=keyList,proto3,oneof"`
}

func (*Key_ContractID) isKey_Key() {}

func (*Key_Ed25519) isKey_Key() {}

func (*Key_RSA_3072) isKey_Key() {}

func (*Key_ECDSA_384) isKey_Key() {}

func (*Key_ThresholdKey) isKey_Key() {}

func (*Key_KeyList) isKey_Key() {}

func (m *Key) GetKey() isKey_Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Key) GetContractID() *ContractID {
	if x, ok := m.GetKey().(*Key_ContractID); ok {
		return x.ContractID
	}
	return nil
}

func (m *Key) GetEd25519() []byte {
	if x, ok := m.GetKey().(*Key_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *Key) GetRSA_3072() []byte {
	if x, ok := m.GetKey().(*Key_RSA_3072); ok {
		return x.RSA_3072
	}
	return nil
}

func (m *Key) GetECDSA_384() []byte {
	if x, ok := m.GetKey().(*Key_ECDSA_384); ok {
		return x.ECDSA_384
	}
	return nil
}

func (m *Key) GetThresholdKey() *ThresholdKey {
	if x, ok := m.GetKey().(*Key_ThresholdKey); ok {
		return x.ThresholdKey
	}
	return nil
}

func (m *Key) GetKeyList() *KeyList {
	if x, ok := m.GetKey().(*Key_KeyList); ok {
		return x.KeyList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Key) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Key_ContractID)(nil),
		(*Key_Ed25519)(nil),
		(*Key_RSA_3072)(nil),
		(*Key_ECDSA_384)(nil),
		(*Key_ThresholdKey)(nil),
		(*Key_KeyList)(nil),
	}
}

// A set of public keys that are used together to form a threshold signature. If the threshold is N and there are M keys, then this is an N of M threshold signature. If an account is associated with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list of M signatures, where at most M-N of them are blank, and the other at least N of them are valid signatures corresponding to at least N of the public keys listed here.
type ThresholdKey struct {
	Threshold            uint32   `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Keys                 *KeyList `protobuf:"bytes,2,opt,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ThresholdKey) Reset()         { *m = ThresholdKey{} }
func (m *ThresholdKey) String() string { return proto.CompactTextString(m) }
func (*ThresholdKey) ProtoMessage()    {}
func (*ThresholdKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{8}
}

func (m *ThresholdKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ThresholdKey.Unmarshal(m, b)
}
func (m *ThresholdKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ThresholdKey.Marshal(b, m, deterministic)
}
func (m *ThresholdKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdKey.Merge(m, src)
}
func (m *ThresholdKey) XXX_Size() int {
	return xxx_messageInfo_ThresholdKey.Size(m)
}
func (m *ThresholdKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdKey.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdKey proto.InternalMessageInfo

func (m *ThresholdKey) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *ThresholdKey) GetKeys() *KeyList {
	if m != nil {
		return m.Keys
	}
	return nil
}

// A list of keys
type KeyList struct {
	Keys                 []*Key   `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyList) Reset()         { *m = KeyList{} }
func (m *KeyList) String() string { return proto.CompactTextString(m) }
func (*KeyList) ProtoMessage()    {}
func (*KeyList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{9}
}

func (m *KeyList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_KeyList.Unmarshal(m, b)
}
func (m *KeyList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_KeyList.Marshal(b, m, deterministic)
}
func (m *KeyList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyList.Merge(m, src)
}
func (m *KeyList) XXX_Size() int {
	return xxx_messageInfo_KeyList.Size(m)
}
func (m *KeyList) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyList.DiscardUnknown(m)
}

var xxx_messageInfo_KeyList proto.InternalMessageInfo

func (m *KeyList) GetKeys() []*Key {
	if m != nil {
		return m.Keys
	}
	return nil
}

// A Signature corresponding to a Key. It is a sequence of bytes holding a public key signature from one of the three supported systems (ed25519, RSA-3072,  ECDSA with p384). Or, it can be a list of signatures corresponding to a single threshold key. Or, it can be the ID of a smart contract instance, which is authorized to act as if it had a key. If an account has an ed25519 key associated with it, then the corresponding private key must sign any transaction to transfer cryptocurrency out of it. If it has a smart contract ID associated with it, then that smart contract is allowed to transfer cryptocurrency out of it. The smart contract doesn't actually have a key, and  doesn't actually sign a transaction. But it's as if a virtual transaction were created, and the smart contract signed it with a private key. A key can also be a "threshold key", which means a list of M keys, any N of which must sign in order for the threshold signature to be considered valid. The keys within a threshold signature may themselves be threshold signatures, to allow complex signature requirements (this nesting is not supported in the currently, but will be supported in a future version of API). If a Signature message is missing the "signature" field, then this is considered to be a null signature. That is useful in cases such as threshold signatures, where some of the signatures can be null.
// The definition of Key uses mutual recursion, so it allows nesting that is arbitrarily deep. But the current API only accepts Key messages up to 3 levels deep, such as a list of threshold keys, each of which is a list of primitive keys. Therefore, the matching Signature will have the same limitation. This restriction may be relaxed in future versions of the API, to allow deeper nesting.
// This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
//
// Deprecated: Do not use.
type Signature struct {
	// Types that are valid to be assigned to Signature:
	//	*Signature_Contract
	//	*Signature_Ed25519
	//	*Signature_RSA_3072
	//	*Signature_ECDSA_384
	//	*Signature_ThresholdSignature
	//	*Signature_SignatureList
	Signature            isSignature_Signature `protobuf_oneof:"signature"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{10}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

type isSignature_Signature interface {
	isSignature_Signature()
}

type Signature_Contract struct {
	Contract []byte `protobuf:"bytes,1,opt,name=contract,proto3,oneof"`
}

type Signature_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,2,opt,name=ed25519,proto3,oneof"`
}

type Signature_RSA_3072 struct {
	RSA_3072 []byte `protobuf:"bytes,3,opt,name=RSA_3072,json=RSA3072,proto3,oneof"`
}

type Signature_ECDSA_384 struct {
	ECDSA_384 []byte `protobuf:"bytes,4,opt,name=ECDSA_384,json=ECDSA384,proto3,oneof"`
}

type Signature_ThresholdSignature struct {
	ThresholdSignature *ThresholdSignature `protobuf:"bytes,5,opt,name=thresholdSignature,proto3,oneof"`
}

type Signature_SignatureList struct {
	SignatureList *SignatureList `protobuf:"bytes,6,opt,name=signatureList,proto3,oneof"`
}

func (*Signature_Contract) isSignature_Signature() {}

func (*Signature_Ed25519) isSignature_Signature() {}

func (*Signature_RSA_3072) isSignature_Signature() {}

func (*Signature_ECDSA_384) isSignature_Signature() {}

func (*Signature_ThresholdSignature) isSignature_Signature() {}

func (*Signature_SignatureList) isSignature_Signature() {}

func (m *Signature) GetSignature() isSignature_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signature) GetContract() []byte {
	if x, ok := m.GetSignature().(*Signature_Contract); ok {
		return x.Contract
	}
	return nil
}

func (m *Signature) GetEd25519() []byte {
	if x, ok := m.GetSignature().(*Signature_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *Signature) GetRSA_3072() []byte {
	if x, ok := m.GetSignature().(*Signature_RSA_3072); ok {
		return x.RSA_3072
	}
	return nil
}

func (m *Signature) GetECDSA_384() []byte {
	if x, ok := m.GetSignature().(*Signature_ECDSA_384); ok {
		return x.ECDSA_384
	}
	return nil
}

func (m *Signature) GetThresholdSignature() *ThresholdSignature {
	if x, ok := m.GetSignature().(*Signature_ThresholdSignature); ok {
		return x.ThresholdSignature
	}
	return nil
}

func (m *Signature) GetSignatureList() *SignatureList {
	if x, ok := m.GetSignature().(*Signature_SignatureList); ok {
		return x.SignatureList
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Signature) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Signature_Contract)(nil),
		(*Signature_Ed25519)(nil),
		(*Signature_RSA_3072)(nil),
		(*Signature_ECDSA_384)(nil),
		(*Signature_ThresholdSignature)(nil),
		(*Signature_SignatureList)(nil),
	}
}

// A signature corresponding to a ThresholdKey. For an N-of-M threshold key, this is a list of M signatures, at least N of which must be non-null.
// This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
//
// Deprecated: Do not use.
type ThresholdSignature struct {
	Sigs                 *SignatureList `protobuf:"bytes,2,opt,name=sigs,proto3" json:"sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ThresholdSignature) Reset()         { *m = ThresholdSignature{} }
func (m *ThresholdSignature) String() string { return proto.CompactTextString(m) }
func (*ThresholdSignature) ProtoMessage()    {}
func (*ThresholdSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{11}
}

func (m *ThresholdSignature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ThresholdSignature.Unmarshal(m, b)
}
func (m *ThresholdSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ThresholdSignature.Marshal(b, m, deterministic)
}
func (m *ThresholdSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdSignature.Merge(m, src)
}
func (m *ThresholdSignature) XXX_Size() int {
	return xxx_messageInfo_ThresholdSignature.Size(m)
}
func (m *ThresholdSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdSignature.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdSignature proto.InternalMessageInfo

func (m *ThresholdSignature) GetSigs() *SignatureList {
	if m != nil {
		return m.Sigs
	}
	return nil
}

// The signatures corresponding to a KeyList of the same length.
// This message is deprecated and succeeded by SignaturePair and SignatureMap messages.
//
// Deprecated: Do not use.
type SignatureList struct {
	Sigs                 []*Signature `protobuf:"bytes,2,rep,name=sigs,proto3" json:"sigs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SignatureList) Reset()         { *m = SignatureList{} }
func (m *SignatureList) String() string { return proto.CompactTextString(m) }
func (*SignatureList) ProtoMessage()    {}
func (*SignatureList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{12}
}

func (m *SignatureList) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureList.Unmarshal(m, b)
}
func (m *SignatureList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureList.Marshal(b, m, deterministic)
}
func (m *SignatureList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureList.Merge(m, src)
}
func (m *SignatureList) XXX_Size() int {
	return xxx_messageInfo_SignatureList.Size(m)
}
func (m *SignatureList) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureList.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureList proto.InternalMessageInfo

func (m *SignatureList) GetSigs() []*Signature {
	if m != nil {
		return m.Sigs
	}
	return nil
}

// The client may use any number of bytes from 0 to the whole length of the public key for pubKeyPrefix.
// If 0 bytes is used, then it is assumed that only one public key is used to sign.
type SignaturePair struct {
	PubKeyPrefix []byte `protobuf:"bytes,1,opt,name=pubKeyPrefix,proto3" json:"pubKeyPrefix,omitempty"`
	// Types that are valid to be assigned to Signature:
	//	*SignaturePair_Contract
	//	*SignaturePair_Ed25519
	//	*SignaturePair_RSA_3072
	//	*SignaturePair_ECDSA_384
	Signature            isSignaturePair_Signature `protobuf_oneof:"signature"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SignaturePair) Reset()         { *m = SignaturePair{} }
func (m *SignaturePair) String() string { return proto.CompactTextString(m) }
func (*SignaturePair) ProtoMessage()    {}
func (*SignaturePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{13}
}

func (m *SignaturePair) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignaturePair.Unmarshal(m, b)
}
func (m *SignaturePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignaturePair.Marshal(b, m, deterministic)
}
func (m *SignaturePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignaturePair.Merge(m, src)
}
func (m *SignaturePair) XXX_Size() int {
	return xxx_messageInfo_SignaturePair.Size(m)
}
func (m *SignaturePair) XXX_DiscardUnknown() {
	xxx_messageInfo_SignaturePair.DiscardUnknown(m)
}

var xxx_messageInfo_SignaturePair proto.InternalMessageInfo

func (m *SignaturePair) GetPubKeyPrefix() []byte {
	if m != nil {
		return m.PubKeyPrefix
	}
	return nil
}

type isSignaturePair_Signature interface {
	isSignaturePair_Signature()
}

type SignaturePair_Contract struct {
	Contract []byte `protobuf:"bytes,2,opt,name=contract,proto3,oneof"`
}

type SignaturePair_Ed25519 struct {
	Ed25519 []byte `protobuf:"bytes,3,opt,name=ed25519,proto3,oneof"`
}

type SignaturePair_RSA_3072 struct {
	RSA_3072 []byte `protobuf:"bytes,4,opt,name=RSA_3072,json=RSA3072,proto3,oneof"`
}

type SignaturePair_ECDSA_384 struct {
	ECDSA_384 []byte `protobuf:"bytes,5,opt,name=ECDSA_384,json=ECDSA384,proto3,oneof"`
}

func (*SignaturePair_Contract) isSignaturePair_Signature() {}

func (*SignaturePair_Ed25519) isSignaturePair_Signature() {}

func (*SignaturePair_RSA_3072) isSignaturePair_Signature() {}

func (*SignaturePair_ECDSA_384) isSignaturePair_Signature() {}

func (m *SignaturePair) GetSignature() isSignaturePair_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignaturePair) GetContract() []byte {
	if x, ok := m.GetSignature().(*SignaturePair_Contract); ok {
		return x.Contract
	}
	return nil
}

func (m *SignaturePair) GetEd25519() []byte {
	if x, ok := m.GetSignature().(*SignaturePair_Ed25519); ok {
		return x.Ed25519
	}
	return nil
}

func (m *SignaturePair) GetRSA_3072() []byte {
	if x, ok := m.GetSignature().(*SignaturePair_RSA_3072); ok {
		return x.RSA_3072
	}
	return nil
}

func (m *SignaturePair) GetECDSA_384() []byte {
	if x, ok := m.GetSignature().(*SignaturePair_ECDSA_384); ok {
		return x.ECDSA_384
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SignaturePair) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SignaturePair_Contract)(nil),
		(*SignaturePair_Ed25519)(nil),
		(*SignaturePair_RSA_3072)(nil),
		(*SignaturePair_ECDSA_384)(nil),
	}
}

// A set of signatures corresponding to every unique public key used to sign a given transaction.
// If one public key matches more than one prefixes on the signature map, the transaction containing the map will fail immediately with the response code KEY_PREFIX_MISMATCH.
type SignatureMap struct {
	SigPair              []*SignaturePair `protobuf:"bytes,1,rep,name=sigPair,proto3" json:"sigPair,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SignatureMap) Reset()         { *m = SignatureMap{} }
func (m *SignatureMap) String() string { return proto.CompactTextString(m) }
func (*SignatureMap) ProtoMessage()    {}
func (*SignatureMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{14}
}

func (m *SignatureMap) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignatureMap.Unmarshal(m, b)
}
func (m *SignatureMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignatureMap.Marshal(b, m, deterministic)
}
func (m *SignatureMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureMap.Merge(m, src)
}
func (m *SignatureMap) XXX_Size() int {
	return xxx_messageInfo_SignatureMap.Size(m)
}
func (m *SignatureMap) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureMap.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureMap proto.InternalMessageInfo

func (m *SignatureMap) GetSigPair() []*SignaturePair {
	if m != nil {
		return m.SigPair
	}
	return nil
}

type FeeComponents struct {
	Min                  int64    `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Max                  int64    `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	Constant             int64    `protobuf:"varint,3,opt,name=constant,proto3" json:"constant,omitempty"`
	Bpt                  int64    `protobuf:"varint,4,opt,name=bpt,proto3" json:"bpt,omitempty"`
	Vpt                  int64    `protobuf:"varint,5,opt,name=vpt,proto3" json:"vpt,omitempty"`
	Rbh                  int64    `protobuf:"varint,6,opt,name=rbh,proto3" json:"rbh,omitempty"`
	Sbh                  int64    `protobuf:"varint,7,opt,name=sbh,proto3" json:"sbh,omitempty"`
	Gas                  int64    `protobuf:"varint,8,opt,name=gas,proto3" json:"gas,omitempty"`
	Tv                   int64    `protobuf:"varint,9,opt,name=tv,proto3" json:"tv,omitempty"`
	Bpr                  int64    `protobuf:"varint,10,opt,name=bpr,proto3" json:"bpr,omitempty"`
	Sbpr                 int64    `protobuf:"varint,11,opt,name=sbpr,proto3" json:"sbpr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FeeComponents) Reset()         { *m = FeeComponents{} }
func (m *FeeComponents) String() string { return proto.CompactTextString(m) }
func (*FeeComponents) ProtoMessage()    {}
func (*FeeComponents) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{15}
}

func (m *FeeComponents) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeComponents.Unmarshal(m, b)
}
func (m *FeeComponents) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeComponents.Marshal(b, m, deterministic)
}
func (m *FeeComponents) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeComponents.Merge(m, src)
}
func (m *FeeComponents) XXX_Size() int {
	return xxx_messageInfo_FeeComponents.Size(m)
}
func (m *FeeComponents) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeComponents.DiscardUnknown(m)
}

var xxx_messageInfo_FeeComponents proto.InternalMessageInfo

func (m *FeeComponents) GetMin() int64 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *FeeComponents) GetMax() int64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *FeeComponents) GetConstant() int64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

func (m *FeeComponents) GetBpt() int64 {
	if m != nil {
		return m.Bpt
	}
	return 0
}

func (m *FeeComponents) GetVpt() int64 {
	if m != nil {
		return m.Vpt
	}
	return 0
}

func (m *FeeComponents) GetRbh() int64 {
	if m != nil {
		return m.Rbh
	}
	return 0
}

func (m *FeeComponents) GetSbh() int64 {
	if m != nil {
		return m.Sbh
	}
	return 0
}

func (m *FeeComponents) GetGas() int64 {
	if m != nil {
		return m.Gas
	}
	return 0
}

func (m *FeeComponents) GetTv() int64 {
	if m != nil {
		return m.Tv
	}
	return 0
}

func (m *FeeComponents) GetBpr() int64 {
	if m != nil {
		return m.Bpr
	}
	return 0
}

func (m *FeeComponents) GetSbpr() int64 {
	if m != nil {
		return m.Sbpr
	}
	return 0
}

// The fees for a specific transaction or query based on the fee data.
type TransactionFeeSchedule struct {
	HederaFunctionality  HederaFunctionality `protobuf:"varint,1,opt,name=hederaFunctionality,proto3,enum=proto.HederaFunctionality" json:"hederaFunctionality,omitempty"`
	FeeData              *FeeData            `protobuf:"bytes,2,opt,name=feeData,proto3" json:"feeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TransactionFeeSchedule) Reset()         { *m = TransactionFeeSchedule{} }
func (m *TransactionFeeSchedule) String() string { return proto.CompactTextString(m) }
func (*TransactionFeeSchedule) ProtoMessage()    {}
func (*TransactionFeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{16}
}

func (m *TransactionFeeSchedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionFeeSchedule.Unmarshal(m, b)
}
func (m *TransactionFeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionFeeSchedule.Marshal(b, m, deterministic)
}
func (m *TransactionFeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionFeeSchedule.Merge(m, src)
}
func (m *TransactionFeeSchedule) XXX_Size() int {
	return xxx_messageInfo_TransactionFeeSchedule.Size(m)
}
func (m *TransactionFeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionFeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionFeeSchedule proto.InternalMessageInfo

func (m *TransactionFeeSchedule) GetHederaFunctionality() HederaFunctionality {
	if m != nil {
		return m.HederaFunctionality
	}
	return HederaFunctionality_NONE
}

func (m *TransactionFeeSchedule) GetFeeData() *FeeData {
	if m != nil {
		return m.FeeData
	}
	return nil
}

// The total fees charged for a transaction. It contains three parts namely node data, network data and service data
type FeeData struct {
	Nodedata             *FeeComponents `protobuf:"bytes,1,opt,name=nodedata,proto3" json:"nodedata,omitempty"`
	Networkdata          *FeeComponents `protobuf:"bytes,2,opt,name=networkdata,proto3" json:"networkdata,omitempty"`
	Servicedata          *FeeComponents `protobuf:"bytes,3,opt,name=servicedata,proto3" json:"servicedata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *FeeData) Reset()         { *m = FeeData{} }
func (m *FeeData) String() string { return proto.CompactTextString(m) }
func (*FeeData) ProtoMessage()    {}
func (*FeeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{17}
}

func (m *FeeData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeData.Unmarshal(m, b)
}
func (m *FeeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeData.Marshal(b, m, deterministic)
}
func (m *FeeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeData.Merge(m, src)
}
func (m *FeeData) XXX_Size() int {
	return xxx_messageInfo_FeeData.Size(m)
}
func (m *FeeData) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeData.DiscardUnknown(m)
}

var xxx_messageInfo_FeeData proto.InternalMessageInfo

func (m *FeeData) GetNodedata() *FeeComponents {
	if m != nil {
		return m.Nodedata
	}
	return nil
}

func (m *FeeData) GetNetworkdata() *FeeComponents {
	if m != nil {
		return m.Networkdata
	}
	return nil
}

func (m *FeeData) GetServicedata() *FeeComponents {
	if m != nil {
		return m.Servicedata
	}
	return nil
}

// The fee schedule for a specific hedera functionality and the time period this fee schedule will expire
type FeeSchedule struct {
	TransactionFeeSchedule []*TransactionFeeSchedule `protobuf:"bytes,1,rep,name=transactionFeeSchedule,proto3" json:"transactionFeeSchedule,omitempty"`
	ExpiryTime             *TimestampSeconds         `protobuf:"bytes,2,opt,name=expiryTime,proto3" json:"expiryTime,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}                  `json:"-"`
	XXX_unrecognized       []byte                    `json:"-"`
	XXX_sizecache          int32                     `json:"-"`
}

func (m *FeeSchedule) Reset()         { *m = FeeSchedule{} }
func (m *FeeSchedule) String() string { return proto.CompactTextString(m) }
func (*FeeSchedule) ProtoMessage()    {}
func (*FeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{18}
}

func (m *FeeSchedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FeeSchedule.Unmarshal(m, b)
}
func (m *FeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FeeSchedule.Marshal(b, m, deterministic)
}
func (m *FeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeSchedule.Merge(m, src)
}
func (m *FeeSchedule) XXX_Size() int {
	return xxx_messageInfo_FeeSchedule.Size(m)
}
func (m *FeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_FeeSchedule proto.InternalMessageInfo

func (m *FeeSchedule) GetTransactionFeeSchedule() []*TransactionFeeSchedule {
	if m != nil {
		return m.TransactionFeeSchedule
	}
	return nil
}

func (m *FeeSchedule) GetExpiryTime() *TimestampSeconds {
	if m != nil {
		return m.ExpiryTime
	}
	return nil
}

// This contains two Fee Schedules with expiry timestamp.
type CurrentAndNextFeeSchedule struct {
	CurrentFeeSchedule   *FeeSchedule `protobuf:"bytes,1,opt,name=currentFeeSchedule,proto3" json:"currentFeeSchedule,omitempty"`
	NextFeeSchedule      *FeeSchedule `protobuf:"bytes,2,opt,name=nextFeeSchedule,proto3" json:"nextFeeSchedule,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *CurrentAndNextFeeSchedule) Reset()         { *m = CurrentAndNextFeeSchedule{} }
func (m *CurrentAndNextFeeSchedule) String() string { return proto.CompactTextString(m) }
func (*CurrentAndNextFeeSchedule) ProtoMessage()    {}
func (*CurrentAndNextFeeSchedule) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{19}
}

func (m *CurrentAndNextFeeSchedule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CurrentAndNextFeeSchedule.Unmarshal(m, b)
}
func (m *CurrentAndNextFeeSchedule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CurrentAndNextFeeSchedule.Marshal(b, m, deterministic)
}
func (m *CurrentAndNextFeeSchedule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentAndNextFeeSchedule.Merge(m, src)
}
func (m *CurrentAndNextFeeSchedule) XXX_Size() int {
	return xxx_messageInfo_CurrentAndNextFeeSchedule.Size(m)
}
func (m *CurrentAndNextFeeSchedule) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentAndNextFeeSchedule.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentAndNextFeeSchedule proto.InternalMessageInfo

func (m *CurrentAndNextFeeSchedule) GetCurrentFeeSchedule() *FeeSchedule {
	if m != nil {
		return m.CurrentFeeSchedule
	}
	return nil
}

func (m *CurrentAndNextFeeSchedule) GetNextFeeSchedule() *FeeSchedule {
	if m != nil {
		return m.NextFeeSchedule
	}
	return nil
}

// The information about a node
type NodeAddress struct {
	IpAddress            []byte   `protobuf:"bytes,1,opt,name=ipAddress,proto3" json:"ipAddress,omitempty"`
	Portno               int32    `protobuf:"varint,2,opt,name=portno,proto3" json:"portno,omitempty"`
	Memo                 []byte   `protobuf:"bytes,3,opt,name=memo,proto3" json:"memo,omitempty"`
	RSA_PubKey           string   `protobuf:"bytes,4,opt,name=RSA_PubKey,json=RSAPubKey,proto3" json:"RSA_PubKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeAddress) Reset()         { *m = NodeAddress{} }
func (m *NodeAddress) String() string { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()    {}
func (*NodeAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{20}
}

func (m *NodeAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAddress.Unmarshal(m, b)
}
func (m *NodeAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAddress.Marshal(b, m, deterministic)
}
func (m *NodeAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddress.Merge(m, src)
}
func (m *NodeAddress) XXX_Size() int {
	return xxx_messageInfo_NodeAddress.Size(m)
}
func (m *NodeAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddress.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddress proto.InternalMessageInfo

func (m *NodeAddress) GetIpAddress() []byte {
	if m != nil {
		return m.IpAddress
	}
	return nil
}

func (m *NodeAddress) GetPortno() int32 {
	if m != nil {
		return m.Portno
	}
	return 0
}

func (m *NodeAddress) GetMemo() []byte {
	if m != nil {
		return m.Memo
	}
	return nil
}

func (m *NodeAddress) GetRSA_PubKey() string {
	if m != nil {
		return m.RSA_PubKey
	}
	return ""
}

// Gives the node addresses in the address book
type NodeAddressBook struct {
	NodeAddress          []*NodeAddress `protobuf:"bytes,1,rep,name=nodeAddress,proto3" json:"nodeAddress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *NodeAddressBook) Reset()         { *m = NodeAddressBook{} }
func (m *NodeAddressBook) String() string { return proto.CompactTextString(m) }
func (*NodeAddressBook) ProtoMessage()    {}
func (*NodeAddressBook) Descriptor() ([]byte, []int) {
	return fileDescriptor_e0596775ed6fb078, []int{21}
}

func (m *NodeAddressBook) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAddressBook.Unmarshal(m, b)
}
func (m *NodeAddressBook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAddressBook.Marshal(b, m, deterministic)
}
func (m *NodeAddressBook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAddressBook.Merge(m, src)
}
func (m *NodeAddressBook) XXX_Size() int {
	return xxx_messageInfo_NodeAddressBook.Size(m)
}
func (m *NodeAddressBook) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAddressBook.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAddressBook proto.InternalMessageInfo

func (m *NodeAddressBook) GetNodeAddress() []*NodeAddress {
	if m != nil {
		return m.NodeAddress
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.HederaFunctionality", HederaFunctionality_name, HederaFunctionality_value)
	proto.RegisterType((*ShardID)(nil), "proto.ShardID")
	proto.RegisterType((*RealmID)(nil), "proto.RealmID")
	proto.RegisterType((*AccountID)(nil), "proto.AccountID")
	proto.RegisterType((*FileID)(nil), "proto.FileID")
	proto.RegisterType((*ContractID)(nil), "proto.ContractID")
	proto.RegisterType((*TransactionID)(nil), "proto.TransactionID")
	proto.RegisterType((*TopicID)(nil), "proto.TopicID")
	proto.RegisterType((*Key)(nil), "proto.Key")
	proto.RegisterType((*ThresholdKey)(nil), "proto.ThresholdKey")
	proto.RegisterType((*KeyList)(nil), "proto.KeyList")
	proto.RegisterType((*Signature)(nil), "proto.Signature")
	proto.RegisterType((*ThresholdSignature)(nil), "proto.ThresholdSignature")
	proto.RegisterType((*SignatureList)(nil), "proto.SignatureList")
	proto.RegisterType((*SignaturePair)(nil), "proto.SignaturePair")
	proto.RegisterType((*SignatureMap)(nil), "proto.SignatureMap")
	proto.RegisterType((*FeeComponents)(nil), "proto.FeeComponents")
	proto.RegisterType((*TransactionFeeSchedule)(nil), "proto.TransactionFeeSchedule")
	proto.RegisterType((*FeeData)(nil), "proto.FeeData")
	proto.RegisterType((*FeeSchedule)(nil), "proto.FeeSchedule")
	proto.RegisterType((*CurrentAndNextFeeSchedule)(nil), "proto.CurrentAndNextFeeSchedule")
	proto.RegisterType((*NodeAddress)(nil), "proto.NodeAddress")
	proto.RegisterType((*NodeAddressBook)(nil), "proto.NodeAddressBook")
}

func init() {
	proto.RegisterFile("proto/BasicTypes.proto", fileDescriptor_e0596775ed6fb078)
}

var fileDescriptor_e0596775ed6fb078 = []byte{
	// 1421 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x5f, 0x4f, 0x1b, 0xc7,
	0x16, 0xc7, 0x36, 0x60, 0xfb, 0xd8, 0xc0, 0x32, 0xfc, 0x33, 0x4e, 0xc8, 0xe5, 0xee, 0xcd, 0x95,
	0xb8, 0x91, 0x02, 0xb9, 0x90, 0x34, 0x49, 0x15, 0x55, 0xb2, 0x21, 0xfc, 0x11, 0x29, 0x45, 0x63,
	0x92, 0x87, 0x48, 0x55, 0x35, 0xec, 0x1e, 0xec, 0x95, 0xed, 0x9d, 0xd5, 0xec, 0x98, 0xb0, 0x7d,
	0xea, 0x53, 0xfb, 0xda, 0x2f, 0x90, 0x4f, 0xd0, 0xf7, 0x7e, 0x9d, 0x7e, 0x95, 0x6a, 0x66, 0x67,
	0xff, 0x18, 0x5c, 0x1e, 0x1a, 0xf5, 0xc9, 0x73, 0x7e, 0xe7, 0x77, 0xfe, 0xcf, 0x9c, 0x35, 0xac,
	0x06, 0x82, 0x4b, 0xbe, 0xd3, 0x66, 0xa1, 0xe7, 0x5c, 0x44, 0x01, 0x86, 0xdb, 0x1a, 0x20, 0x33,
	0xfa, 0xa7, 0xb9, 0x12, 0xab, 0x2f, 0xbc, 0x21, 0x86, 0x92, 0x0d, 0x83, 0x58, 0x6b, 0xff, 0x17,
	0xca, 0x9d, 0x1e, 0x13, 0xee, 0xc9, 0x01, 0x69, 0x42, 0x25, 0x54, 0xc7, 0xb3, 0xd1, 0xb0, 0x51,
	0xd8, 0x2c, 0x6c, 0x95, 0x68, 0x2a, 0xdb, 0x2d, 0x28, 0x53, 0x64, 0x83, 0xe1, 0xfd, 0x34, 0xa5,
	0x13, 0x8a, 0xa6, 0x74, 0xc5, 0x58, 0x97, 0xc8, 0xb6, 0x03, 0xd5, 0x96, 0xe3, 0xf0, 0x91, 0x2f,
	0xff, 0xbe, 0x13, 0xf2, 0x08, 0x80, 0xc5, 0x4e, 0x94, 0xb6, 0xa4, 0xb5, 0x39, 0xc4, 0xfe, 0x08,
	0xb3, 0x87, 0xde, 0x00, 0xbf, 0x20, 0x42, 0x03, 0xca, 0x57, 0xde, 0x00, 0x33, 0xf7, 0x89, 0x68,
	0x5f, 0x01, 0xec, 0x73, 0x5f, 0x0a, 0xe6, 0x7c, 0x49, 0x05, 0x9b, 0x50, 0x73, 0x8c, 0x97, 0x2c,
	0x46, 0x1e, 0xb2, 0x7f, 0x29, 0xc0, 0xdc, 0x85, 0x60, 0x7e, 0xc8, 0x1c, 0xe9, 0x71, 0xff, 0xe4,
	0x80, 0x1c, 0xc2, 0x8a, 0xcc, 0x80, 0x0f, 0x6c, 0xe0, 0xb9, 0x1d, 0xc9, 0x84, 0xd4, 0x81, 0x6b,
	0xbb, 0x56, 0x3c, 0xcb, 0xed, 0x74, 0xb6, 0x74, 0x32, 0x9d, 0x6c, 0x43, 0x95, 0x25, 0x23, 0xd0,
	0x89, 0x65, 0xb6, 0xe9, 0x68, 0x68, 0x46, 0xb1, 0xbf, 0x87, 0xf2, 0x05, 0x0f, 0x3c, 0xe7, 0x0b,
	0xca, 0x6d, 0x42, 0x45, 0x2a, 0x17, 0x59, 0xad, 0xa9, 0x6c, 0xff, 0x54, 0x84, 0xd2, 0x29, 0x46,
	0x64, 0x0f, 0xc0, 0x49, 0x1b, 0x6b, 0x6a, 0x5a, 0x34, 0x79, 0x65, 0x1d, 0x3f, 0x9e, 0xa2, 0x39,
	0x1a, 0x69, 0x42, 0x19, 0xdd, 0xdd, 0x17, 0x2f, 0xfe, 0xff, 0x5a, 0xc7, 0xac, 0x1f, 0x4f, 0xd1,
	0x04, 0x20, 0x0f, 0xa0, 0x42, 0x3b, 0xad, 0x1f, 0xf6, 0x9e, 0xbd, 0xdc, 0xd5, 0x41, 0xb5, 0x92,
	0x76, 0x5a, 0x0a, 0x20, 0x1b, 0x50, 0x7d, 0xbb, 0x7f, 0xa0, 0xd4, 0xaf, 0x9e, 0x37, 0xa6, 0x8d,
	0xb6, 0xa2, 0xa1, 0xbd, 0x57, 0xcf, 0xc9, 0x6b, 0xa8, 0xcb, 0x9e, 0xc0, 0xb0, 0xc7, 0x07, 0xee,
	0x29, 0x46, 0x8d, 0x19, 0x9d, 0xce, 0x52, 0xd2, 0xe2, 0x9c, 0xea, 0x78, 0x8a, 0x8e, 0x51, 0xc9,
	0x13, 0x28, 0xf7, 0x31, 0x7a, 0xe7, 0x85, 0xb2, 0x31, 0xab, 0xad, 0xe6, 0x8d, 0xd5, 0x69, 0x8c,
	0xaa, 0x2c, 0x0c, 0xa1, 0x3d, 0x03, 0xa5, 0x3e, 0x46, 0xf6, 0x39, 0xd4, 0xf3, 0x2e, 0xc9, 0x43,
	0xa8, 0xa6, 0x2e, 0x75, 0x27, 0xe6, 0x68, 0x06, 0x10, 0x1b, 0xa6, 0xfb, 0x18, 0x85, 0x66, 0x74,
	0xb7, 0xbc, 0x53, 0xad, 0xb3, 0xff, 0x07, 0x65, 0x03, 0x90, 0x47, 0x86, 0x5e, 0xd8, 0x2c, 0x6d,
	0xd5, 0x76, 0x21, 0xa3, 0x1b, 0xea, 0xe7, 0x22, 0x54, 0x3b, 0x5e, 0xd7, 0x67, 0x72, 0x24, 0x90,
	0x3c, 0x84, 0x4a, 0xd2, 0x5e, 0x1d, 0x59, 0xb7, 0x25, 0x41, 0xfe, 0xb1, 0x76, 0x9f, 0x02, 0x49,
	0xeb, 0x4b, 0x73, 0x31, 0x4d, 0x5f, 0xbf, 0xdd, 0xf4, 0x94, 0x70, 0x3c, 0x45, 0x27, 0x98, 0x91,
	0x37, 0x30, 0x17, 0x26, 0x42, 0x6e, 0x0c, 0xcb, 0xc6, 0x4f, 0x27, 0xaf, 0x3b, 0x9e, 0xa2, 0xe3,
	0xe4, 0xaf, 0x8b, 0x8d, 0x42, 0xbb, 0x06, 0xd5, 0x14, 0xb4, 0xdb, 0x40, 0xee, 0x86, 0x26, 0x5b,
	0x30, 0x1d, 0x7a, 0xdd, 0x64, 0x08, 0x13, 0x7d, 0x53, 0xcd, 0x50, 0x0e, 0xed, 0xd7, 0x30, 0x37,
	0xa6, 0x22, 0x8f, 0x53, 0xf3, 0x52, 0xee, 0xf9, 0xa5, 0x9c, 0x9c, 0xe9, 0xef, 0x85, 0x9c, 0xed,
	0x39, 0xf3, 0x04, 0xb1, 0xa1, 0x1e, 0x8c, 0x2e, 0x4f, 0x31, 0x3a, 0x17, 0x78, 0xe5, 0xdd, 0xc4,
	0x63, 0xa2, 0x63, 0xd8, 0xd8, 0x18, 0x8b, 0xf7, 0x8d, 0xb1, 0x74, 0xdf, 0x18, 0xa7, 0xef, 0x1d,
	0xe3, 0xcc, 0xed, 0x31, 0x8e, 0xf7, 0xed, 0x1b, 0xa8, 0xa7, 0x79, 0x7f, 0xcb, 0x02, 0xb2, 0x0d,
	0xe5, 0xd0, 0xeb, 0xaa, 0x0a, 0xcc, 0x55, 0xbc, 0xd3, 0x34, 0xa5, 0xa3, 0x09, 0xc9, 0xfe, 0xa3,
	0x00, 0x73, 0x87, 0x88, 0xfb, 0x7c, 0x18, 0x70, 0x1f, 0x7d, 0x19, 0x12, 0x0b, 0x4a, 0x43, 0xcf,
	0x37, 0x8b, 0x47, 0x1d, 0x35, 0xc2, 0x6e, 0xcc, 0xba, 0x51, 0x47, 0xb5, 0x69, 0x1c, 0xee, 0x87,
	0x92, 0xf9, 0x32, 0xd9, 0x34, 0x89, 0xac, 0xd8, 0x97, 0x81, 0xd4, 0x55, 0x95, 0xa8, 0x3a, 0x2a,
	0xe4, 0x3a, 0x90, 0xba, 0x92, 0x12, 0x55, 0x47, 0x85, 0x88, 0xcb, 0x9e, 0xbe, 0x32, 0x25, 0xaa,
	0x8e, 0x0a, 0x09, 0x2f, 0x7b, 0x8d, 0x72, 0x8c, 0x84, 0x31, 0xd2, 0x65, 0x61, 0xa3, 0x12, 0x23,
	0x5d, 0x16, 0x92, 0x79, 0x28, 0xca, 0xeb, 0x46, 0x55, 0x03, 0x45, 0x79, 0x1d, 0x47, 0x12, 0x0d,
	0x48, 0x22, 0x09, 0x42, 0x60, 0x3a, 0x54, 0x50, 0x4d, 0x43, 0xfa, 0x6c, 0xff, 0x5a, 0x80, 0xd5,
	0xdc, 0x8a, 0x3f, 0x44, 0xec, 0x38, 0x3d, 0x74, 0x47, 0x03, 0x24, 0xef, 0x60, 0xa9, 0x87, 0x2e,
	0x0a, 0x76, 0x38, 0xf2, 0xb5, 0x92, 0x0d, 0x3c, 0x19, 0xe9, 0xd2, 0xe7, 0x77, 0x9b, 0xa6, 0x71,
	0xc7, 0x77, 0x19, 0x74, 0x92, 0x19, 0xd9, 0x82, 0xf2, 0x15, 0xe2, 0x01, 0x93, 0xec, 0xd6, 0xd2,
	0x38, 0x8c, 0x51, 0x9a, 0xa8, 0xed, 0xdf, 0x0a, 0x50, 0x36, 0x20, 0x79, 0x06, 0x15, 0x9f, 0xbb,
	0xe8, 0x2a, 0xb3, 0xc2, 0xd8, 0x35, 0x1f, 0x1b, 0x0b, 0x4d, 0x59, 0xe4, 0x2b, 0xa8, 0xf9, 0x28,
	0x3f, 0x71, 0xd1, 0x77, 0xb3, 0x58, 0x93, 0x8d, 0xf2, 0x44, 0x65, 0x17, 0xa2, 0xb8, 0xf6, 0x9c,
	0x38, 0x58, 0xe9, 0x3e, 0xbb, 0x1c, 0xd1, 0xfe, 0x5c, 0x80, 0x5a, 0xbe, 0x6b, 0xef, 0x61, 0x55,
	0x4e, 0xec, 0xa7, 0xb9, 0x71, 0x1b, 0xc9, 0x2a, 0x99, 0x48, 0xa2, 0x7f, 0x61, 0x4c, 0x5e, 0x02,
	0xe0, 0x4d, 0xe0, 0x89, 0x48, 0x7d, 0x5a, 0x4d, 0x55, 0x6b, 0xb7, 0xbf, 0xb6, 0x1d, 0x74, 0xb8,
	0xef, 0x86, 0x34, 0x47, 0x55, 0xf9, 0xad, 0xef, 0x8f, 0x84, 0x40, 0x5f, 0xb6, 0x7c, 0xf7, 0x0c,
	0x6f, 0x64, 0xde, 0x6d, 0x1b, 0x88, 0x13, 0x2b, 0xc7, 0x33, 0x55, 0xee, 0x49, 0x56, 0x7c, 0x9a,
	0xde, 0x04, 0x36, 0x79, 0x03, 0x0b, 0xfe, 0xb8, 0x5b, 0x93, 0xdf, 0x24, 0x07, 0xb7, 0xa9, 0xf6,
	0x35, 0xd4, 0xce, 0xb8, 0x8b, 0x2d, 0xd7, 0x15, 0x18, 0x86, 0xea, 0xb3, 0xe3, 0x05, 0x46, 0x30,
	0x5b, 0x25, 0x03, 0xc8, 0x2a, 0xcc, 0x06, 0x5c, 0x48, 0x9f, 0xeb, 0x08, 0x33, 0xd4, 0x48, 0xea,
	0x66, 0x0f, 0x71, 0xc8, 0xe3, 0x4d, 0x42, 0xf5, 0x99, 0x6c, 0x00, 0xa8, 0x25, 0x72, 0xae, 0x57,
	0x92, 0x7e, 0x70, 0x55, 0x5a, 0xa5, 0x9d, 0x56, 0x0c, 0xd8, 0x47, 0xb0, 0x90, 0x8b, 0xdb, 0xe6,
	0xbc, 0x4f, 0x9e, 0x43, 0xcd, 0xcf, 0x20, 0x33, 0xaf, 0xa4, 0x88, 0x1c, 0x99, 0xe6, 0x69, 0x4f,
	0x7e, 0x9e, 0x85, 0xa5, 0x09, 0xaf, 0x80, 0x54, 0x60, 0xfa, 0xec, 0xbb, 0xb3, 0xb7, 0xd6, 0x14,
	0x21, 0x30, 0xbf, 0x2f, 0xa2, 0x40, 0x72, 0x3d, 0xf3, 0x2b, 0x14, 0x56, 0x81, 0x58, 0x50, 0x8f,
	0xb1, 0xf7, 0x81, 0xcb, 0x24, 0x5a, 0xc5, 0x0c, 0x39, 0xc0, 0x01, 0x4a, 0xb4, 0x4a, 0x99, 0x5d,
	0xcb, 0x75, 0xf7, 0x07, 0xcc, 0x1b, 0x5a, 0xd3, 0x64, 0x05, 0x16, 0xf3, 0xac, 0x18, 0x9e, 0xd1,
	0xc6, 0x66, 0xb3, 0xee, 0xb3, 0xc1, 0xc0, 0x9a, 0xd5, 0xc6, 0x09, 0x22, 0x50, 0x85, 0x28, 0xe7,
	0x31, 0x13, 0xb6, 0x42, 0xe6, 0x01, 0xd4, 0xff, 0x54, 0xc3, 0xa9, 0x26, 0x72, 0x2b, 0x08, 0xd0,
	0x77, 0x2d, 0x48, 0x64, 0xc3, 0xaf, 0x25, 0xb2, 0x49, 0xb2, 0x4e, 0x1e, 0xc0, 0x5a, 0x9c, 0xd0,
	0x11, 0x4a, 0xf3, 0xd7, 0xad, 0xcd, 0x06, 0xcc, 0x77, 0xd0, 0x9a, 0x9b, 0xa4, 0xa4, 0xe8, 0x70,
	0xe1, 0x86, 0xd6, 0x3c, 0x59, 0x84, 0xb9, 0x54, 0x79, 0xe2, 0x5f, 0x71, 0x6b, 0x41, 0x57, 0x97,
	0x2b, 0xe3, 0x1d, 0x77, 0xd8, 0xc0, 0xb2, 0xc8, 0x12, 0x2c, 0x24, 0x70, 0xc2, 0x5d, 0x24, 0x6b,
	0xb0, 0x94, 0x03, 0xdb, 0x91, 0x44, 0x87, 0xbb, 0x68, 0x11, 0xc5, 0xd6, 0x40, 0x87, 0x0f, 0x3c,
	0xd7, 0x93, 0xd1, 0xc9, 0x81, 0xb5, 0x44, 0xea, 0x50, 0xd1, 0xe0, 0x29, 0x46, 0xd6, 0x72, 0xd6,
	0xd9, 0x23, 0x94, 0x71, 0x0b, 0x57, 0xc8, 0x32, 0x58, 0x29, 0xd6, 0x91, 0xac, 0x8f, 0x22, 0xb4,
	0x56, 0x95, 0x33, 0x55, 0xae, 0xe2, 0x71, 0x5f, 0xaa, 0xe7, 0x6f, 0xad, 0x91, 0x05, 0xa8, 0x19,
	0x50, 0xe7, 0xd2, 0x20, 0x0d, 0x58, 0xce, 0xbd, 0xe7, 0x23, 0x34, 0x55, 0x5a, 0xeb, 0x64, 0x15,
	0x48, 0x2e, 0xcb, 0xa4, 0xf8, 0x66, 0x36, 0x6d, 0xd3, 0xf8, 0x07, 0x0a, 0xe9, 0x44, 0xa1, 0xc4,
	0xa1, 0x69, 0xed, 0x43, 0x95, 0x65, 0x8c, 0xbc, 0xf7, 0xdd, 0x18, 0xdb, 0xc8, 0x8f, 0xd0, 0xf0,
	0x1e, 0x11, 0x80, 0xd9, 0x43, 0x81, 0xf8, 0x23, 0x5a, 0xff, 0x8a, 0x3b, 0xae, 0x3c, 0xe6, 0xf2,
	0x31, 0xc9, 0x6c, 0x92, 0x26, 0xac, 0x9a, 0x0b, 0x15, 0xcf, 0xa2, 0x35, 0x92, 0x9c, 0xa2, 0x8f,
	0x9f, 0xac, 0x7f, 0xe7, 0x5b, 0x9f, 0xc1, 0xb6, 0x1a, 0x77, 0x17, 0xe5, 0x07, 0x14, 0xa1, 0xc7,
	0x7d, 0xeb, 0x3f, 0x64, 0x1d, 0x56, 0xee, 0x54, 0x8a, 0x5e, 0x20, 0xad, 0xc7, 0xed, 0x63, 0x68,
	0x3a, 0x7c, 0xb8, 0x1d, 0x2f, 0xff, 0xed, 0x1e, 0x0b, 0x7b, 0x5d, 0xc1, 0x82, 0x5e, 0xfc, 0x7e,
	0xce, 0x0b, 0x1f, 0xb7, 0xba, 0x9e, 0xec, 0x8d, 0x2e, 0xb7, 0x1d, 0x3e, 0xdc, 0x49, 0xb5, 0x3b,
	0x31, 0xfd, 0x69, 0xe8, 0xf6, 0x9f, 0x76, 0xf9, 0x8e, 0xe6, 0x5e, 0xce, 0xea, 0x9f, 0xbd, 0x3f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x42, 0x1b, 0x7c, 0x2d, 0x49, 0x0e, 0x00, 0x00,
}
