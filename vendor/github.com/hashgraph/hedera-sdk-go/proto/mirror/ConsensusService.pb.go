// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/mirror/ConsensusService.proto

package mirror

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	proto1 "github.com/hashgraph/hedera-sdk-go/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ConsensusTopicQuery struct {
	TopicID *proto1.TopicID `protobuf:"bytes,1,opt,name=topicID,proto3" json:"topicID,omitempty"`
	// Include messages which reached consensus on or after this time. Defaults to current time if not set.
	ConsensusStartTime *proto1.Timestamp `protobuf:"bytes,2,opt,name=consensusStartTime,proto3" json:"consensusStartTime,omitempty"`
	// Include messages which reached consensus before this time. If not set it will receive indefinitely.
	ConsensusEndTime *proto1.Timestamp `protobuf:"bytes,3,opt,name=consensusEndTime,proto3" json:"consensusEndTime,omitempty"`
	// The maximum number of messages to receive before stopping. If not set or set to zero it will return messages
	// indefinitely.
	Limit                uint64   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusTopicQuery) Reset()         { *m = ConsensusTopicQuery{} }
func (m *ConsensusTopicQuery) String() string { return proto.CompactTextString(m) }
func (*ConsensusTopicQuery) ProtoMessage()    {}
func (*ConsensusTopicQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_129c3e647d492733, []int{0}
}

func (m *ConsensusTopicQuery) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsensusTopicQuery.Unmarshal(m, b)
}
func (m *ConsensusTopicQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsensusTopicQuery.Marshal(b, m, deterministic)
}
func (m *ConsensusTopicQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusTopicQuery.Merge(m, src)
}
func (m *ConsensusTopicQuery) XXX_Size() int {
	return xxx_messageInfo_ConsensusTopicQuery.Size(m)
}
func (m *ConsensusTopicQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusTopicQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusTopicQuery proto.InternalMessageInfo

func (m *ConsensusTopicQuery) GetTopicID() *proto1.TopicID {
	if m != nil {
		return m.TopicID
	}
	return nil
}

func (m *ConsensusTopicQuery) GetConsensusStartTime() *proto1.Timestamp {
	if m != nil {
		return m.ConsensusStartTime
	}
	return nil
}

func (m *ConsensusTopicQuery) GetConsensusEndTime() *proto1.Timestamp {
	if m != nil {
		return m.ConsensusEndTime
	}
	return nil
}

func (m *ConsensusTopicQuery) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ConsensusTopicResponse struct {
	ConsensusTimestamp *proto1.Timestamp `protobuf:"bytes,1,opt,name=consensusTimestamp,proto3" json:"consensusTimestamp,omitempty"`
	// The message body originally in the ConsensusSubmitMessageTransactionBody. Message size will be less than 4K.
	Message              []byte   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	RunningHash          []byte   `protobuf:"bytes,3,opt,name=runningHash,proto3" json:"runningHash,omitempty"`
	SequenceNumber       uint64   `protobuf:"varint,4,opt,name=sequenceNumber,proto3" json:"sequenceNumber,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConsensusTopicResponse) Reset()         { *m = ConsensusTopicResponse{} }
func (m *ConsensusTopicResponse) String() string { return proto.CompactTextString(m) }
func (*ConsensusTopicResponse) ProtoMessage()    {}
func (*ConsensusTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_129c3e647d492733, []int{1}
}

func (m *ConsensusTopicResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConsensusTopicResponse.Unmarshal(m, b)
}
func (m *ConsensusTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConsensusTopicResponse.Marshal(b, m, deterministic)
}
func (m *ConsensusTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusTopicResponse.Merge(m, src)
}
func (m *ConsensusTopicResponse) XXX_Size() int {
	return xxx_messageInfo_ConsensusTopicResponse.Size(m)
}
func (m *ConsensusTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusTopicResponse proto.InternalMessageInfo

func (m *ConsensusTopicResponse) GetConsensusTimestamp() *proto1.Timestamp {
	if m != nil {
		return m.ConsensusTimestamp
	}
	return nil
}

func (m *ConsensusTopicResponse) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *ConsensusTopicResponse) GetRunningHash() []byte {
	if m != nil {
		return m.RunningHash
	}
	return nil
}

func (m *ConsensusTopicResponse) GetSequenceNumber() uint64 {
	if m != nil {
		return m.SequenceNumber
	}
	return 0
}

func init() {
	proto.RegisterType((*ConsensusTopicQuery)(nil), "com.hedera.mirror.api.proto.ConsensusTopicQuery")
	proto.RegisterType((*ConsensusTopicResponse)(nil), "com.hedera.mirror.api.proto.ConsensusTopicResponse")
}

func init() {
	proto.RegisterFile("proto/mirror/ConsensusService.proto", fileDescriptor_129c3e647d492733)
}

var fileDescriptor_129c3e647d492733 = []byte{
	// 369 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0x4f, 0x4f, 0xf2, 0x40,
	0x10, 0xc6, 0xb3, 0xef, 0xcb, 0xfb, 0x92, 0x2c, 0x84, 0x90, 0x55, 0x49, 0x83, 0x17, 0xc4, 0xc4,
	0xe0, 0x81, 0x96, 0xc0, 0xd5, 0x83, 0x41, 0x4d, 0xf4, 0x62, 0xb0, 0xf6, 0xe4, 0x6d, 0x5b, 0x26,
	0xed, 0x46, 0xfb, 0xc7, 0x9d, 0x5d, 0x13, 0x3e, 0x84, 0x5f, 0xc9, 0x6f, 0xe1, 0xf7, 0x31, 0xed,
	0xb6, 0x0d, 0x20, 0x92, 0x78, 0x9c, 0x67, 0xe6, 0x37, 0x33, 0xcf, 0xee, 0xd0, 0xd3, 0x4c, 0xa6,
	0x2a, 0x75, 0x62, 0x21, 0x65, 0x2a, 0x9d, 0xab, 0x34, 0x41, 0x48, 0x50, 0xe3, 0x23, 0xc8, 0x37,
	0x11, 0x80, 0x5d, 0x64, 0xd9, 0x71, 0x90, 0xc6, 0x76, 0x04, 0x4b, 0x90, 0xdc, 0x36, 0x95, 0x36,
	0xcf, 0x84, 0x49, 0xf6, 0x7b, 0xa6, 0xc3, 0x9c, 0xa3, 0x08, 0xbc, 0x55, 0x06, 0x58, 0xea, 0x47,
	0x46, 0xf7, 0x44, 0x0c, 0xa8, 0x78, 0x9c, 0x19, 0x79, 0xf8, 0x49, 0xe8, 0x41, 0x3d, 0xc6, 0x4b,
	0x33, 0x11, 0x3c, 0x68, 0x90, 0x2b, 0x36, 0xa2, 0x4d, 0x95, 0x47, 0x77, 0xd7, 0x16, 0x19, 0x90,
	0x51, 0x6b, 0xda, 0x31, 0x80, 0xed, 0x19, 0xd5, 0xad, 0xd2, 0xec, 0x92, 0xb2, 0xa0, 0xde, 0x53,
	0x71, 0xa9, 0xf2, 0x11, 0xd6, 0x9f, 0x02, 0xea, 0x56, 0x50, 0x35, 0xd5, 0xdd, 0x51, 0xcb, 0x2e,
	0x68, 0xb7, 0x56, 0x6f, 0x92, 0x65, 0xc1, 0xff, 0xfd, 0x81, 0xff, 0x56, 0xc9, 0x0e, 0xe9, 0xbf,
	0x17, 0x11, 0x0b, 0x65, 0x35, 0x06, 0x64, 0xd4, 0x70, 0x4d, 0x30, 0xfc, 0x20, 0xb4, 0xb7, 0xe9,
	0xcb, 0x05, 0xcc, 0x72, 0x61, 0x63, 0xe1, 0xba, 0x71, 0xe9, 0x72, 0xdf, 0xc2, 0xb5, 0xc6, 0x2c,
	0xda, 0x8c, 0x01, 0x91, 0x87, 0xc6, 0x67, 0xdb, 0xad, 0x42, 0x36, 0xa0, 0x2d, 0xa9, 0x93, 0x44,
	0x24, 0xe1, 0x2d, 0xc7, 0xa8, 0x70, 0xd1, 0x76, 0xd7, 0x25, 0x76, 0x46, 0x3b, 0x08, 0xaf, 0x1a,
	0x92, 0x00, 0xee, 0x75, 0xec, 0x83, 0x2c, 0xf7, 0xde, 0x52, 0xa7, 0xef, 0x84, 0x76, 0xb7, 0xff,
	0x9f, 0xad, 0x68, 0x07, 0xb5, 0x8f, 0x81, 0x14, 0x3e, 0x14, 0xa6, 0xd8, 0xc4, 0xde, 0x73, 0x0c,
	0xf6, 0x8e, 0x9f, 0xed, 0xcf, 0x7e, 0x41, 0x54, 0x6f, 0x36, 0x21, 0xf3, 0x05, 0x3d, 0x59, 0xe3,
	0x22, 0x8e, 0x51, 0x28, 0x79, 0x16, 0x95, 0x98, 0xe9, 0xb3, 0x20, 0x4f, 0xe7, 0xa1, 0x50, 0x91,
	0xf6, 0xf3, 0x19, 0x4e, 0x5d, 0xe4, 0x18, 0x6a, 0x8c, 0xcb, 0xe7, 0x71, 0x58, 0x5d, 0xb7, 0xff,
	0xbf, 0x40, 0x67, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xf4, 0xbe, 0xaa, 0xf4, 0x02, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ConsensusServiceClient is the client API for ConsensusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ConsensusServiceClient interface {
	SubscribeTopic(ctx context.Context, in *ConsensusTopicQuery, opts ...grpc.CallOption) (ConsensusService_SubscribeTopicClient, error)
}

type consensusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConsensusServiceClient(cc grpc.ClientConnInterface) ConsensusServiceClient {
	return &consensusServiceClient{cc}
}

func (c *consensusServiceClient) SubscribeTopic(ctx context.Context, in *ConsensusTopicQuery, opts ...grpc.CallOption) (ConsensusService_SubscribeTopicClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ConsensusService_serviceDesc.Streams[0], "/com.hedera.mirror.api.proto.ConsensusService/subscribeTopic", opts...)
	if err != nil {
		return nil, err
	}
	x := &consensusServiceSubscribeTopicClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ConsensusService_SubscribeTopicClient interface {
	Recv() (*ConsensusTopicResponse, error)
	grpc.ClientStream
}

type consensusServiceSubscribeTopicClient struct {
	grpc.ClientStream
}

func (x *consensusServiceSubscribeTopicClient) Recv() (*ConsensusTopicResponse, error) {
	m := new(ConsensusTopicResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ConsensusServiceServer is the server API for ConsensusService service.
type ConsensusServiceServer interface {
	SubscribeTopic(*ConsensusTopicQuery, ConsensusService_SubscribeTopicServer) error
}

// UnimplementedConsensusServiceServer can be embedded to have forward compatible implementations.
type UnimplementedConsensusServiceServer struct {
}

func (*UnimplementedConsensusServiceServer) SubscribeTopic(req *ConsensusTopicQuery, srv ConsensusService_SubscribeTopicServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeTopic not implemented")
}

func RegisterConsensusServiceServer(s *grpc.Server, srv ConsensusServiceServer) {
	s.RegisterService(&_ConsensusService_serviceDesc, srv)
}

func _ConsensusService_SubscribeTopic_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsensusTopicQuery)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ConsensusServiceServer).SubscribeTopic(m, &consensusServiceSubscribeTopicServer{stream})
}

type ConsensusService_SubscribeTopicServer interface {
	Send(*ConsensusTopicResponse) error
	grpc.ServerStream
}

type consensusServiceSubscribeTopicServer struct {
	grpc.ServerStream
}

func (x *consensusServiceSubscribeTopicServer) Send(m *ConsensusTopicResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ConsensusService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.hedera.mirror.api.proto.ConsensusService",
	HandlerType: (*ConsensusServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "subscribeTopic",
			Handler:       _ConsensusService_SubscribeTopic_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/mirror/ConsensusService.proto",
}
